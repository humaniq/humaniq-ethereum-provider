{"mappings":"AEEA,QAAQ,MAAM,CAAC;IACb,UAAU,MAAM;QACd,kBAAkB,EAAE;YAClB,WAAW,CAAC,GAAG,EAAE,MAAM,GAAG,IAAI,CAAC;YAC/B,SAAS,CAAC,GAAG,EAAE,MAAM,GAAG,IAAI,CAAA;SAC7B,CAAC;QACF,QAAQ,EAAE,GAAG,CAAC;QACd,+BAA+B,EAAE,MAAM,CAAA;QACvC,mBAAmB,EAAE,MAAM,CAAA;QAC3B,eAAe,EAAE,OAAO,CAAA;KACzB;CACF;AAED,OAAO,IAAI,kBAAc,CAAA;AACzB,OAAO,IAAI,WAAW;IAAE,CAAC,GAAG,EAAE,MAAM,GAAG,GAAG,CAAA;CAAO,CAAA;AAEjD,+BAA+B,UAAU,EAAE,MAAM,EAAE,IAAI,CAAC,EAAE,GAAG,oBAgB5D;AAED;IACE,cAAc,yBAEb;CACF;AAED;IACE,SAAS,UAAO;IAChB,UAAU,UAAO;IACjB,OAAO,aAAmB;IAC1B,WAAW,gBAAa;IAExB,cAAc,SAA6B;IAC3C,OAAO,SAAyD;IAChE,SAAS,SAA6B;IAGtC,MAAM;IAIN,UAAU,CAAC,KAAK,EAAE,MAAM;IAIxB,SAAS,YAAa,GAAG,YAAY,GAAG,0CAsCvC;IAED,QAAQ,YAAa,GAAG;;;;MAcvB;IAED,OAAO,qBAAsB,GAAG;;;;qCAsD/B;IAED,IAAI,WAAY,GAAG;;;;qCAKlB;IACD,OAAO,EAAE,GAAG,CAAK;IACjB,EAAE,SAAU,GAAG,YAAY,GAAG,UAK7B;IAED,cAAc,SAAU,GAAG,oBAAoB,GAAG,UAOjD;IAED,kBAAkB,aAEjB;IAED,IAAI,SAAU,GAAG,QAAQ,GAAG,UAK3B;CACF","sources":["src/src/utils.ts","src/src/messages.ts","src/src/index.ts","src/index.ts"],"sourcesContent":[null,null,null,"import { bridgeSend, getSyncResponse, web3Response } from \"./messages\";\r\n\r\ndeclare global {\r\n  interface Window {\r\n    ReactNativeWebView: {\r\n      postMessage(msg: string): void;\r\n      onMessage(msg: string): void\r\n    };\r\n    ethereum: any,\r\n    humaniqAppcurrentAccountAddress: string\r\n    humaniqAppNetworkId: number\r\n    humaniqAppDebug: boolean\r\n  }\r\n}\r\n\r\nexport let callbackId = 0\r\nexport let callbacks: { [key: number]: any } = {}\r\n\r\nexport function sendAPIrequest(permission: string, pars?: any) {\r\n  const messageId = callbackId++\r\n  const params = pars || {}\r\n\r\n  bridgeSend({\r\n    type: 'api-request',\r\n    permission: permission,\r\n    messageId: messageId,\r\n    params: params\r\n  })\r\n\r\n  return new Promise(function (resolve, reject: any) {\r\n    params['resolve'] = resolve\r\n    params['reject'] = reject\r\n    callbacks[messageId] = params\r\n  })\r\n}\r\n\r\nexport class HumaniqAPI {\r\n  getContactCode = () => {\r\n    return sendAPIrequest('contact-code')\r\n  }\r\n}\r\n\r\nexport class EthereumProvider {\r\n  isHumaniq = true\r\n  isMetamask = true\r\n  humaniq = new HumaniqAPI()\r\n  isConnected = () => true\r\n\r\n  networkVersion = window.humaniqAppNetworkId\r\n  chainId = \"0x\" + Number(window.humaniqAppNetworkId).toString(16)\r\n  networkId = window.humaniqAppNetworkId\r\n\r\n\r\n  enable() {\r\n    return sendAPIrequest('web3', { url: location.href })\r\n  }\r\n\r\n  scanQRCode(regex: string) {\r\n    return sendAPIrequest('qr-code', { regex: regex })\r\n  }\r\n\r\n  sendAsync = (payload: any, callback: any) => {\r\n    if (window.humaniqAppDebug) {\r\n      console.log(\"sendAsync (legacy)\" + JSON.stringify(payload))\r\n    }\r\n    if (!payload) {\r\n      return new Error('Request is not valid.')\r\n    }\r\n    if (payload.method == 'eth_requestAccounts') {\r\n      return sendAPIrequest('web3', { url: location.href })\r\n    }\r\n    var syncResponse = getSyncResponse(payload)\r\n    if (syncResponse && callback) {\r\n      callback(null, syncResponse)\r\n    } else {\r\n      var messageId = callbackId++\r\n\r\n      if (Array.isArray(payload)) {\r\n        callbacks[messageId] = {\r\n          num: payload.length,\r\n          results: [],\r\n          callback: callback\r\n        }\r\n        for (var i in payload) {\r\n          bridgeSend({\r\n            type: 'web3-send-async-read-only',\r\n            messageId: messageId,\r\n            payload: payload[i]\r\n          })\r\n        }\r\n      } else {\r\n        callbacks[messageId] = { callback: callback }\r\n        bridgeSend({\r\n          type: 'web3-send-async-read-only',\r\n          messageId: messageId,\r\n          payload: payload\r\n        })\r\n      }\r\n    }\r\n  }\r\n\r\n  sendSync = (payload: any) => {\r\n    if (window.humaniqAppDebug) {\r\n      console.log(\"sendSync (legacy)\" + JSON.stringify(payload))\r\n    }\r\n    if (payload.method == \"eth_uninstallFilter\") {\r\n      this.sendAsync(payload, function (res: any, err: any) {\r\n      })\r\n    }\r\n    const syncResponse = getSyncResponse(payload)\r\n    if (syncResponse) {\r\n      return syncResponse\r\n    } else {\r\n      return web3Response(payload, null)\r\n    }\r\n  }\r\n\r\n  request = (requestArguments: any) => {\r\n    try {\r\n      if (!requestArguments) {\r\n        return new Error('Request is not valid.')\r\n      }\r\n      const method = requestArguments.method\r\n\r\n      if (!method) {\r\n        return new Error('Request is not valid.')\r\n      }\r\n\r\n      // Support for legacy send method\r\n      if (typeof method !== 'string') {\r\n        return this.sendSync(method)\r\n      }\r\n\r\n      if (method === 'eth_requestAccounts') {\r\n        return sendAPIrequest('web3', { url: location.href })\r\n      }\r\n\r\n      const syncResponse = getSyncResponse({ method: method })\r\n      if (syncResponse) {\r\n        return new Promise(function (resolve, reject) {\r\n          resolve(syncResponse.result)\r\n        })\r\n      }\r\n\r\n      const messageId = callbackId++\r\n      const payload = {\r\n        id: messageId,\r\n        jsonrpc: \"2.0\",\r\n        method: method,\r\n        params: requestArguments.params\r\n      }\r\n\r\n      bridgeSend({\r\n        type: 'web3-send-async-read-only',\r\n        messageId: messageId,\r\n        payload: payload,\r\n        meta: {\r\n          url: location.href\r\n        }\r\n      })\r\n\r\n      return new Promise(function (resolve, reject) {\r\n        callbacks[messageId] = {\r\n          beta: true,\r\n          resolve: resolve,\r\n          reject: reject\r\n        }\r\n      })\r\n    } catch (e) {\r\n      bridgeSend({ error: e })\r\n    }\r\n  }\r\n\r\n  send = (method: any, params = []) => {\r\n    if (window.humaniqAppDebug) {\r\n      console.log(\"send (legacy): \" + method)\r\n    }\r\n    return this.request({ method: method, params: params })\r\n  }\r\n  _events: any = {}\r\n  on = (name: any, listener: any) => {\r\n    if (!this._events[name]) {\r\n      this._events[name] = []\r\n    }\r\n    this._events[name].push(listener)\r\n  }\r\n\r\n  removeListener = (name: any, listenerToRemove: any) => {\r\n    if (!this._events[name]) {\r\n      return\r\n    }\r\n\r\n    const filterListeners = (listener: any) => listener !== listenerToRemove\r\n    this._events[name] = this._events[name].filter(filterListeners)\r\n  }\r\n\r\n  removeAllListeners = () => {\r\n    this._events = []\r\n  }\r\n\r\n  emit = (name: any, data: any) => {\r\n    if (!this._events[name]) {\r\n      return\r\n    }\r\n    this._events[name].forEach((cb: any) => cb(data))\r\n  }\r\n}\r\n\r\nwindow.ethereum = new EthereumProvider()\r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n"],"names":[],"version":3,"file":"types.d.ts.map"}